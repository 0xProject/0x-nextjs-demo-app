"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var A=require("events"),h=require("@walletconnect/utils"),T=require("@walletconnect/universal-provider");function R(i){if(i&&i.__esModule)return i;var t=Object.create(null);return i&&Object.keys(i).forEach(function(e){if(e!=="default"){var s=Object.getOwnPropertyDescriptor(i,e);Object.defineProperty(t,e,s.get?s:{enumerable:!0,get:function(){return i[e]}})}}),t.default=i,Object.freeze(t)}const S="wc",j="ethereum_provider",N=`${S}@${2}:${j}:`,q="https://rpc.walletconnect.com/v1/",u=["eth_sendTransaction","personal_sign"],D=["eth_accounts","eth_requestAccounts","eth_call","eth_getBalance","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode"],m=["chainChanged","accountsChanged"],$=["message","disconnect","connect"];var U=Object.defineProperty,Q=Object.defineProperties,L=Object.getOwnPropertyDescriptors,_=Object.getOwnPropertySymbols,V=Object.prototype.hasOwnProperty,H=Object.prototype.propertyIsEnumerable,O=(i,t,e)=>t in i?U(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,I=(i,t)=>{for(var e in t||(t={}))V.call(t,e)&&O(i,e,t[e]);if(_)for(var e of _(t))H.call(t,e)&&O(i,e,t[e]);return i},y=(i,t)=>Q(i,L(t));function C(i){return Number(i[0].split(":")[1])}function E(i){return`0x${i.toString(16)}`}function z(i){const{chains:t,optionalChains:e,methods:s,optionalMethods:n,events:a,optionalEvents:l,rpcMap:c}=i;if(!h.isValidArray(t))throw new Error("Invalid chains");const o=t,r=s||u,f=a||m,b={[C(o)]:c[C(o)]},w={chains:o,methods:r,events:f,rpcMap:b},d=a?.filter(v=>!m.includes(v)),p=s?.filter(v=>!u.includes(v));if(!e&&!l&&!n&&!(d!=null&&d.length)&&!(p!=null&&p.length))return{required:w};const M=d?.length&&p?.length||!e,P={chains:[...new Set(M?o.concat(e||[]):e)],methods:[...new Set(r.concat(n||[]))],events:[...new Set(f.concat(l||[]))],rpcMap:c};return{required:w,optional:P}}class g{constructor(){this.events=new A.EventEmitter,this.namespace="eip155",this.accounts=[],this.chainId=1,this.STORAGE_KEY=N,this.on=(t,e)=>(this.events.on(t,e),this),this.once=(t,e)=>(this.events.once(t,e),this),this.removeListener=(t,e)=>(this.events.removeListener(t,e),this),this.off=(t,e)=>(this.events.off(t,e),this),this.parseAccount=t=>this.isCompatibleChainId(t)?this.parseAccountId(t).address:t,this.signer={},this.rpc={}}static async init(t){const e=new g;return await e.initialize(t),e}async request(t){return await this.signer.request(t,this.formatChainId(this.chainId))}sendAsync(t,e){this.signer.sendAsync(t,e,this.formatChainId(this.chainId))}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(t);const{required:e,optional:s}=z(this.rpc);try{const n=await new Promise(async(l,c)=>{var o;this.rpc.showQrModal&&((o=this.modal)==null||o.subscribeModal(r=>{!r.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),c(new Error("Connection request reset. Please try again.")))})),await this.signer.connect(y(I({namespaces:{[this.namespace]:e}},s&&{optionalNamespaces:{[this.namespace]:s}}),{pairingTopic:t?.pairingTopic})).then(r=>{l(r)}).catch(r=>{c(new Error(r.message))})});if(!n)return;this.setChainIds(this.rpc.chains);const a=h.getAccountsFromNamespaces(n.namespaces,[this.namespace]);this.setAccounts(a),this.events.emit("connect",{chainId:E(this.chainId)})}catch(n){throw this.signer.logger.error(n),n}finally{this.modal&&this.modal.closeModal()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",t=>{const{params:e}=t,{event:s}=e;s.name==="accountsChanged"?(this.accounts=this.parseAccounts(s.data),this.events.emit("accountsChanged",this.accounts)):s.name==="chainChanged"?this.setChainId(this.formatChainId(s.data)):this.events.emit(s.name,s.data),this.events.emit("session_event",t)}),this.signer.on("chainChanged",t=>{const e=parseInt(t);this.chainId=e,this.events.emit("chainChanged",E(this.chainId)),this.persist()}),this.signer.on("session_update",t=>{this.events.emit("session_update",t)}),this.signer.on("session_delete",t=>{this.reset(),this.events.emit("session_delete",t),this.events.emit("disconnect",y(I({},h.getSdkError("USER_DISCONNECTED")),{data:t.topic,name:"USER_DISCONNECTED"}))}),this.signer.on("display_uri",t=>{var e,s;this.rpc.showQrModal&&((e=this.modal)==null||e.closeModal(),(s=this.modal)==null||s.openModal({uri:t})),this.events.emit("display_uri",t)})}setHttpProvider(t){this.request({method:"wallet_switchEthereumChain",params:[{chainId:t.toString(16)}]})}isCompatibleChainId(t){return typeof t=="string"?t.startsWith(`${this.namespace}:`):!1}formatChainId(t){return`${this.namespace}:${t}`}parseChainId(t){return Number(t.split(":")[1])}setChainIds(t){const e=t.filter(s=>this.isCompatibleChainId(s)).map(s=>this.parseChainId(s));e.length&&(this.chainId=e[0],this.events.emit("chainChanged",E(this.chainId)),this.persist())}setChainId(t){if(this.isCompatibleChainId(t)){const e=this.parseChainId(t);this.chainId=e,this.setHttpProvider(e)}}parseAccountId(t){const[e,s,n]=t.split(":");return{chainId:`${e}:${s}`,address:n}}setAccounts(t){this.accounts=t.filter(e=>this.parseChainId(this.parseAccountId(e).chainId)===this.chainId).map(e=>this.parseAccountId(e).address),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(t){var e,s;return{chains:((e=t.chains)==null?void 0:e.map(n=>this.formatChainId(n)))||[`${this.namespace}:1`],optionalChains:t.optionalChains?t.optionalChains.map(n=>this.formatChainId(n)):void 0,methods:t?.methods||u,events:t?.events||m,optionalMethods:t?.optionalMethods||[],optionalEvents:t?.optionalEvents||[],rpcMap:t?.rpcMap||this.buildRpcMap(t.chains.concat(t.optionalChains||[]),t.projectId),showQrModal:Boolean(t?.showQrModal),qrModalOptions:(s=t?.qrModalOptions)!=null?s:void 0,projectId:t.projectId,metadata:t.metadata}}buildRpcMap(t,e){const s={};return t.forEach(n=>{s[n]=this.getRpcUrl(n,e)}),s}async initialize(t){if(this.rpc=this.getRpcConfig(t),this.chainId=C(this.rpc.chains),this.signer=await T.UniversalProvider.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:t.disableProviderPing}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal)try{const{Web3Modal:e}=await Promise.resolve().then(function(){return R(require("@web3modal/standalone"))});this.modal=new e(I({walletConnectVersion:2,projectId:this.rpc.projectId,standaloneChains:this.rpc.chains},this.rpc.qrModalOptions))}catch{throw new Error("To use QR modal, please install @web3modal/standalone package")}}loadConnectOpts(t){if(!t)return;const{chains:e,optionalChains:s,rpcMap:n}=t;e&&h.isValidArray(e)&&(this.rpc.chains=e.map(a=>this.formatChainId(a)),e.forEach(a=>{this.rpc.rpcMap[a]=n?.[a]||this.getRpcUrl(a)})),s&&h.isValidArray(s)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=s?.map(a=>this.formatChainId(a)),s.forEach(a=>{this.rpc.rpcMap[a]=n?.[a]||this.getRpcUrl(a)}))}getRpcUrl(t,e){var s;return((s=this.rpc.rpcMap)==null?void 0:s[t])||`${q}?chainId=eip155:${t}&projectId=${e||this.rpc.projectId}`}async loadPersistedSession(){if(!this.session)return;const t=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);this.setChainIds(t?[this.formatChainId(t)]:this.session.namespaces[this.namespace].accounts),this.setAccounts(this.session.namespaces[this.namespace].accounts)}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(t){return typeof t=="string"||t instanceof String?[this.parseAccount(t)]:t.map(e=>this.parseAccount(e))}}const G=g;exports.EthereumProvider=G,exports.OPTIONAL_EVENTS=$,exports.OPTIONAL_METHODS=D,exports.REQUIRED_EVENTS=m,exports.REQUIRED_METHODS=u,exports.default=g;
//# sourceMappingURL=index.cjs.js.map
