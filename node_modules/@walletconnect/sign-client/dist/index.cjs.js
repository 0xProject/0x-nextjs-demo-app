"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var S=require("@walletconnect/core"),O=require("@walletconnect/logger"),M=require("@walletconnect/types"),i=require("@walletconnect/utils"),b=require("events"),p=require("@walletconnect/time"),d=require("@walletconnect/jsonrpc-utils");function F(h){return h&&typeof h=="object"&&"default"in h?h:{default:h}}var H=F(b);const D="wc",A=2,C="client",f=`${D}@${A}:${C}:`,V={name:C,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},B={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire"},Q={database:":memory:"},W={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Z="history",ee="0.3",U="proposal",se=p.THIRTY_DAYS,$="Proposal expired",Y="session",v=p.SEVEN_DAYS,J="engine",R={wc_sessionPropose:{req:{ttl:p.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:p.ONE_DAY,prompt:!1,tag:1104},res:{ttl:p.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:p.ONE_DAY,prompt:!1,tag:1106},res:{ttl:p.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:p.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:p.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:p.ONE_DAY,prompt:!1,tag:1112},res:{ttl:p.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:p.THIRTY_SECONDS,prompt:!1,tag:1114},res:{ttl:p.THIRTY_SECONDS,prompt:!1,tag:1115}}},T={min:p.FIVE_MINUTES,max:p.SEVEN_DAYS},K="request",X=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"];var te=Object.defineProperty,ie=Object.defineProperties,re=Object.getOwnPropertyDescriptors,j=Object.getOwnPropertySymbols,ne=Object.prototype.hasOwnProperty,oe=Object.prototype.propertyIsEnumerable,k=(h,n,e)=>n in h?te(h,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[n]=e,m=(h,n)=>{for(var e in n||(n={}))ne.call(n,e)&&k(h,e,n[e]);if(j)for(var e of j(n))oe.call(n,e)&&k(h,e,n[e]);return h},L=(h,n)=>ie(h,re(n));class ae extends M.IEngine{constructor(n){super(n),this.name=J,this.events=new H.default,this.initialized=!1,this.ignoredPayloadTypes=[i.TYPE_1],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(R)}),this.initialized=!0)},this.connect=async e=>{this.isInitialized();const s=L(m({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s);const{pairingTopic:t,requiredNamespaces:r,optionalNamespaces:o,sessionProperties:c,relays:a}=s;let l=t,g,w=!1;if(l&&(w=this.client.core.pairing.pairings.get(l).active),!l||!w){const{topic:_,uri:I}=await this.client.core.pairing.create();l=_,g=I}const E=await this.client.core.crypto.generateKeyPair(),y=m({requiredNamespaces:r,optionalNamespaces:o,relays:a??[{protocol:S.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:E,metadata:this.client.metadata}},c&&{sessionProperties:c}),{reject:u,resolve:N,done:x}=i.createDelayedPromise(p.FIVE_MINUTES,$);if(this.events.once(i.engineEvent("session_connect"),async({error:_,session:I})=>{if(_)u(_);else if(I){I.self.publicKey=E;const G=L(m({},I),{requiredNamespaces:I.requiredNamespaces,optionalNamespaces:I.optionalNamespaces});await this.client.session.set(I.topic,G),await this.setExpiry(I.topic,I.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:I.peer.metadata}),N(G)}}),!l){const{message:_}=i.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(_)}const P=await this.sendRequest(l,"wc_sessionPropose",y),z=i.calcExpiry(p.FIVE_MINUTES);return await this.setProposal(P,m({id:P,expiry:z},y)),{uri:g,approval:x}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:r,sessionProperties:o}=e,c=this.client.proposal.get(s);let{pairingTopic:a,proposer:l,requiredNamespaces:g,optionalNamespaces:w}=c;a=a||"",i.isValidObject(g)||(g=i.getRequiredNamespacesFromNamespaces(r,"approve()"));const E=await this.client.core.crypto.generateKeyPair(),y=l.publicKey,u=await this.client.core.crypto.generateSharedKey(E,y);a&&s&&(await this.client.core.pairing.updateMetadata({topic:a,metadata:l.metadata}),await this.sendResult(s,a,{relay:{protocol:t??"irn"},responderPublicKey:E}),await this.client.proposal.delete(s,i.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:a}));const N=m({relay:{protocol:t??"irn"},namespaces:r,requiredNamespaces:g,optionalNamespaces:w,pairingTopic:a,controller:{publicKey:E,metadata:this.client.metadata},expiry:i.calcExpiry(v)},o&&{sessionProperties:o});await this.client.core.relayer.subscribe(u),await this.sendRequest(u,"wc_sessionSettle",N);const x=L(m({},N),{topic:u,pairingTopic:a,acknowledged:!1,self:N.controller,peer:{publicKey:l.publicKey,metadata:l.metadata},controller:E});return await this.client.session.set(u,x),await this.setExpiry(u,i.calcExpiry(v)),{topic:u,acknowledged:()=>new Promise(P=>setTimeout(()=>P(this.client.session.get(u)),500))}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:r}=this.client.proposal.get(s);r&&(await this.sendError(s,r,t),await this.client.proposal.delete(s,i.getSdkError("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,r=await this.sendRequest(s,"wc_sessionUpdate",{namespaces:t}),{done:o,resolve:c,reject:a}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_update",r),({error:l})=>{l?a(l):c()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:o}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest(s,"wc_sessionExtend",{}),{done:r,resolve:o,reject:c}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_extend",t),({error:a})=>{a?c(a):o()}),await this.setExpiry(s,i.calcExpiry(v)),{acknowledged:r}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:r,expiry:o}=e,c=await this.sendRequest(r,"wc_sessionRequest",{request:t,chainId:s},o),{done:a,resolve:l,reject:g}=i.createDelayedPromise(o);return this.events.once(i.engineEvent("session_request",c),({error:w,result:E})=>{w?g(w):l(E)}),this.client.events.emit("session_request_sent",{topic:r,request:t,chainId:s,id:c}),await a()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:r}=t;d.isJsonRpcResult(t)?await this.sendResult(r,s,t.result):d.isJsonRpcError(t)&&await this.sendError(r,s,t.error),this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0})},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest(s,"wc_sessionPing",{}),{done:r,resolve:o,reject:c}=i.createDelayedPromise();this.events.once(i.engineEvent("session_ping",t),({error:a})=>{a?c(a):o()}),await r()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:r}=e;await this.sendRequest(s,"wc_sessionEvent",{event:t,chainId:r})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;this.client.session.keys.includes(s)?(await this.sendRequest(s,"wc_sessionDelete",i.getSdkError("USER_DISCONNECTED")),await this.deleteSession(s)):await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>i.isSessionCompatible(s,e))),this.getPendingSessionRequests=()=>(this.isInitialized(),this.client.pendingRequest.getAll()),this.cleanupDuplicatePairings=async e=>{try{const s=this.client.core.pairing.pairings.get(e.pairingTopic),t=this.client.core.pairing.pairings.getAll().filter(r=>{var o,c;return((o=r.peerMetadata)==null?void 0:o.url)&&((c=r.peerMetadata)==null?void 0:c.url)===e.self.metadata.url&&r.topic!==s.topic});if(t.length===0)return;this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`),await Promise.all(t.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}},this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await Promise.all([this.client.session.delete(e,i.getSdkError("USER_DISCONNECTED")),this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.deleteSymKey(e),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deletePendingSessionRequest=async(e,s,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,s),t?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.setPendingSessionRequest=async e=>{const s=R.wc_sessionRequest.req.ttl,{id:t,topic:r,params:o}=e;await this.client.pendingRequest.set(t,{id:t,topic:r,params:o}),s&&this.client.core.expirer.set(t,i.calcExpiry(s))},this.sendRequest=async(e,s,t,r)=>{const o=d.formatJsonRpcRequest(s,t);if(i.isBrowser()&&X.includes(s)){const l=i.hashMessage(JSON.stringify(o));await this.client.core.verify.register({attestationId:l})}const c=await this.client.core.crypto.encode(e,o),a=R[s].req;return r&&(a.ttl=r),this.client.core.history.set(e,o),this.client.core.relayer.publish(e,c,a),o.id},this.sendResult=async(e,s,t)=>{const r=d.formatJsonRpcResult(e,t),o=await this.client.core.crypto.encode(s,r),c=await this.client.core.history.get(s,e),a=R[c.request.method].res;this.client.core.relayer.publish(s,o,a),await this.client.core.history.resolve(r)},this.sendError=async(e,s,t)=>{const r=d.formatJsonRpcError(e,t),o=await this.client.core.crypto.encode(s,r),c=await this.client.core.history.get(s,e),a=R[c.request.method].res;this.client.core.relayer.publish(s,o,a),await this.client.core.history.resolve(r)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{i.isExpired(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{i.isExpired(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=e=>{const{topic:s,payload:t}=e,r=t.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${r}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,r=(await this.client.core.history.get(s,t.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:r}=s;try{this.isValidConnect(m({},s.params));const o=i.calcExpiry(p.FIVE_MINUTES),c=m({id:r,pairingTopic:e,expiry:o},t);await this.setProposal(r,c);const a=i.hashMessage(JSON.stringify(s)),l=await this.getVerifyContext(a,c.proposer.metadata);this.client.events.emit("session_proposal",{id:r,params:c,verifyContext:l})}catch(o){await this.sendError(r,e,o),this.client.logger.error(o)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(d.isJsonRpcResult(s)){const{result:r}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const o=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const c=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const a=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const l=await this.client.core.crypto.generateSharedKey(c,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const g=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:g}),await this.client.core.pairing.activate({topic:e})}else d.isJsonRpcError(s)&&(await this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_connect"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:r}=s;try{this.isValidSessionSettleRequest(r);const{relay:o,controller:c,expiry:a,namespaces:l,requiredNamespaces:g,optionalNamespaces:w,sessionProperties:E,pairingTopic:y}=s.params,u=m({topic:e,relay:o,expiry:a,namespaces:l,acknowledged:!0,pairingTopic:y,requiredNamespaces:g,optionalNamespaces:w,controller:c.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:c.publicKey,metadata:c.metadata}},E&&{sessionProperties:E});await this.sendResult(s.id,e,!0),this.events.emit(i.engineEvent("session_connect"),{session:u}),this.cleanupDuplicatePairings(u)}catch(o){await this.sendError(t,e,o),this.client.logger.error(o)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(i.engineEvent("session_approve",t),{})):d.isJsonRpcError(s)&&(await this.client.session.delete(e,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_approve",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:r}=s;try{this.isValidUpdate(m({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult(r,e,!0),this.client.events.emit("session_update",{id:r,topic:e,params:t})}catch(o){await this.sendError(r,e,o),this.client.logger.error(o)}},this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?this.events.emit(i.engineEvent("session_update",t),{}):d.isJsonRpcError(s)&&this.events.emit(i.engineEvent("session_update",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,i.calcExpiry(v)),await this.sendResult(t,e,!0),this.client.events.emit("session_extend",{id:t,topic:e})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?this.events.emit(i.engineEvent("session_extend",t),{}):d.isJsonRpcError(s)&&this.events.emit(i.engineEvent("session_extend",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult(t,e,!0),this.client.events.emit("session_ping",{id:t,topic:e})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{d.isJsonRpcResult(s)?this.events.emit(i.engineEvent("session_ping",t),{}):d.isJsonRpcError(s)&&this.events.emit(i.engineEvent("session_ping",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await Promise.all([new Promise(r=>{this.client.core.relayer.once(S.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession(e))})}),this.sendResult(t,e,!0)]),this.client.events.emit("session_delete",{id:t,topic:e})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:r}=s;try{this.isValidRequest(m({topic:e},r)),await this.setPendingSessionRequest({id:t,topic:e,params:r});const o=i.hashMessage(JSON.stringify(s)),c=this.client.session.get(e),a=await this.getVerifyContext(o,c.peer.metadata);this.client.events.emit("session_request",{id:t,topic:e,params:r,verifyContext:a})}catch(o){await this.sendError(t,e,o),this.client.logger.error(o)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?this.events.emit(i.engineEvent("session_request",t),{result:s.result}):d.isJsonRpcError(s)&&this.events.emit(i.engineEvent("session_request",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:r}=s;try{this.isValidEmit(m({topic:e},r)),this.client.events.emit("session_event",{id:t,topic:e,params:r})}catch(o){await this.sendError(t,e,o),this.client.logger.error(o)}},this.isValidConnect=async e=>{if(!i.isValidParams(e)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(a)}const{pairingTopic:s,requiredNamespaces:t,optionalNamespaces:r,sessionProperties:o,relays:c}=e;if(i.isUndefined(s)||await this.isValidPairingTopic(s),!i.isValidRelays(c,!0)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`connect() relays: ${c}`);throw new Error(a)}!i.isUndefined(t)&&i.isValidObject(t)!==0&&this.validateNamespaces(t,"requiredNamespaces"),!i.isUndefined(r)&&i.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),i.isUndefined(o)||this.validateSessionProps(o,"sessionProperties")},this.validateNamespaces=(e,s)=>{const t=i.isValidRequiredNamespaces(e,"connect()",s);if(t)throw new Error(t.message)},this.isValidApprove=async e=>{if(!i.isValidParams(e))throw new Error(i.getInternalError("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:r,sessionProperties:o}=e;await this.isValidProposalId(s);const c=this.client.proposal.get(s),a=i.isValidNamespaces(t,"approve()");if(a)throw new Error(a.message);const l=i.isConformingNamespaces(c.requiredNamespaces,t,"approve()");if(l)throw new Error(l.message);if(!i.isValidString(r,!0)){const{message:g}=i.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(g)}i.isUndefined(o)||this.validateSessionProps(o,"sessionProperties")},this.isValidReject=async e=>{if(!i.isValidParams(e)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(r)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!i.isValidErrorReason(t)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(r)}},this.isValidSessionSettleRequest=e=>{if(!i.isValidParams(e)){const{message:l}=i.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:s,controller:t,namespaces:r,expiry:o}=e;if(!i.isValidRelay(s)){const{message:l}=i.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const c=i.isValidController(t,"onSessionSettleRequest()");if(c)throw new Error(c.message);const a=i.isValidNamespaces(r,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(i.isExpired(o)){const{message:l}=i.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!i.isValidParams(e)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(a)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const r=this.client.session.get(s),o=i.isValidNamespaces(t,"update()");if(o)throw new Error(o.message);const c=i.isConformingNamespaces(r.requiredNamespaces,t,"update()");if(c)throw new Error(c.message)},this.isValidExtend=async e=>{if(!i.isValidParams(e)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!i.isValidParams(e)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:s,request:t,chainId:r,expiry:o}=e;await this.isValidSessionTopic(s);const{namespaces:c}=this.client.session.get(s);if(!i.isValidNamespacesChainId(c,r)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(a)}if(!i.isValidRequest(t)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(a)}if(!i.isValidNamespacesRequest(c,r,t.method)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(a)}if(o&&!i.isValidRequestExpiry(o,T)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`request() expiry: ${o}. Expiry must be a number (in seconds) between ${T.min} and ${T.max}`);throw new Error(a)}},this.isValidRespond=async e=>{if(!i.isValidParams(e)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(r)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!i.isValidResponse(t)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(t)}`);throw new Error(r)}},this.isValidPing=async e=>{if(!i.isValidParams(e)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!i.isValidParams(e)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(c)}const{topic:s,event:t,chainId:r}=e;await this.isValidSessionTopic(s);const{namespaces:o}=this.client.session.get(s);if(!i.isValidNamespacesChainId(o,r)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(c)}if(!i.isValidEvent(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(c)}if(!i.isValidNamespacesEvent(o,r,t.name)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(c)}},this.isValidDisconnect=async e=>{if(!i.isValidParams(e)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.getVerifyContext=async(e,s)=>{const t={verified:{verifyUrl:s.verifyUrl||"",validation:"UNKNOWN",origin:s.url||""}};try{const r=await this.client.core.verify.resolve({attestationId:e,verifyUrl:s.verifyUrl});r&&(t.verified.origin=r,t.verified.validation=r===s.url?"VALID":"INVALID")}catch(r){this.client.logger.error(r)}return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`),t},this.validateSessionProps=(e,s)=>{Object.values(e).forEach(t=>{if(!i.isValidString(t,!1)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);throw new Error(r)}})}}isInitialized(){if(!this.initialized){const{message:n}=i.getInternalError("NOT_INITIALIZED",this.name);throw new Error(n)}}registerRelayerEvents(){this.client.core.relayer.on(S.RELAYER_EVENTS.message,async n=>{const{topic:e,message:s}=n;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);d.isJsonRpcRequest(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):d.isJsonRpcResponse(t)&&(await this.client.core.history.resolve(t),this.onRelayEventResponse({topic:e,payload:t}))})}registerExpirerEvents(){this.client.core.expirer.on(S.EXPIRER_EVENTS.expired,async n=>{const{topic:e,id:s}=i.parseExpirerTarget(n.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,i.getInternalError("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit("session_expire",{topic:e})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}isValidPairingTopic(n){if(!i.isValidString(n,!1)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(e)}if(i.isExpired(this.client.core.pairing.pairings.get(n).expiry)){const{message:e}=i.getInternalError("EXPIRED",`pairing topic: ${n}`);throw new Error(e)}}async isValidSessionTopic(n){if(!i.isValidString(n,!1)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(e)}if(!this.client.session.keys.includes(n)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(e)}if(i.isExpired(this.client.session.get(n).expiry)){await this.deleteSession(n);const{message:e}=i.getInternalError("EXPIRED",`session topic: ${n}`);throw new Error(e)}}async isValidSessionOrPairingTopic(n){if(this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else if(this.client.core.pairing.pairings.keys.includes(n))this.isValidPairingTopic(n);else if(i.isValidString(n,!1)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(e)}else{const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(e)}}async isValidProposalId(n){if(!i.isValidId(n)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(e)}if(!this.client.proposal.keys.includes(n)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(e)}if(i.isExpired(this.client.proposal.get(n).expiry)){await this.deleteProposal(n);const{message:e}=i.getInternalError("EXPIRED",`proposal id: ${n}`);throw new Error(e)}}}class ce extends S.Store{constructor(n,e){super(n,e,U,f),this.core=n,this.logger=e}}class le extends S.Store{constructor(n,e){super(n,e,Y,f),this.core=n,this.logger=e}}class pe extends S.Store{constructor(n,e){super(n,e,K,f,s=>s.id),this.core=n,this.logger=e}}class q extends M.ISignClient{constructor(n){super(n),this.protocol=D,this.version=A,this.name=V.name,this.events=new b.EventEmitter,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.removeAllListeners=s=>this.events.removeAllListeners(s),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}},this.name=n?.name||V.name,this.metadata=n?.metadata||i.getAppMetadata();const e=typeof n?.logger<"u"&&typeof n?.logger!="string"?n.logger:O.pino(O.getDefaultLoggerOptions({level:n?.logger||V.logger}));this.core=n?.core||new S.Core(n),this.logger=O.generateChildLogger(e,this.name),this.session=new le(this.core,this.logger),this.proposal=new ce(this.core,this.logger),this.pendingRequest=new pe(this.core,this.logger),this.engine=new ae(this)}static async init(n){const e=new q(n);return await e.initialize(),e}get context(){return O.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const he=q;exports.ENGINE_CONTEXT=J,exports.ENGINE_RPC_OPTS=R,exports.HISTORY_CONTEXT=Z,exports.HISTORY_EVENTS=W,exports.HISTORY_STORAGE_VERSION=ee,exports.METHODS_TO_VERIFY=X,exports.PROPOSAL_CONTEXT=U,exports.PROPOSAL_EXPIRY=se,exports.PROPOSAL_EXPIRY_MESSAGE=$,exports.REQUEST_CONTEXT=K,exports.SESSION_CONTEXT=Y,exports.SESSION_EXPIRY=v,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=T,exports.SIGN_CLIENT_CONTEXT=C,exports.SIGN_CLIENT_DEFAULT=V,exports.SIGN_CLIENT_EVENTS=B,exports.SIGN_CLIENT_PROTOCOL=D,exports.SIGN_CLIENT_STORAGE_OPTIONS=Q,exports.SIGN_CLIENT_STORAGE_PREFIX=f,exports.SIGN_CLIENT_VERSION=A,exports.SignClient=he,exports.default=q;
//# sourceMappingURL=index.cjs.js.map
