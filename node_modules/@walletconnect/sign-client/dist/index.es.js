import{RELAYER_DEFAULT_PROTOCOL as le,RELAYER_EVENTS as F,EXPIRER_EVENTS as pe,Store as U,Core as he}from"@walletconnect/core";import{pino as de,getDefaultLoggerOptions as ge,generateChildLogger as me,getLoggerContext as ue}from"@walletconnect/logger";import{IEngine as we,ISignClient as ye}from"@walletconnect/types";import{TYPE_1 as Se,createDelayedPromise as T,engineEvent as p,getInternalError as c,calcExpiry as _,isValidObject as K,getRequiredNamespacesFromNamespaces as Ie,getSdkError as E,isSessionCompatible as _e,isBrowser as Ee,hashMessage as z,isExpired as P,isValidParams as S,isUndefined as x,isValidRelays as Re,isValidRequiredNamespaces as Ne,isValidNamespaces as Y,isConformingNamespaces as B,isValidString as D,isValidErrorReason as fe,isValidRelay as ve,isValidController as Pe,isValidNamespacesChainId as Q,isValidRequest as qe,isValidNamespacesRequest as Oe,isValidRequestExpiry as Ve,isValidResponse as Te,isValidEvent as xe,isValidNamespacesEvent as De,parseExpirerTarget as Ae,isValidId as Ce,getAppMetadata as Le}from"@walletconnect/utils";import be,{EventEmitter as Ge}from"events";import{THIRTY_DAYS as $e,SEVEN_DAYS as W,FIVE_MINUTES as u,ONE_DAY as q,THIRTY_SECONDS as Z}from"@walletconnect/time";import{isJsonRpcResult as R,isJsonRpcError as N,formatJsonRpcRequest as Me,formatJsonRpcResult as Ue,formatJsonRpcError as Ke,isJsonRpcRequest as ze,isJsonRpcResponse as Ye}from"@walletconnect/jsonrpc-utils";const j="wc",k=2,J="client",L=`${j}@${k}:${J}:`,b={name:J,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},je={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire"},ke={database:":memory:"},Je={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Xe="history",He="0.3",ee="proposal",Fe=$e,se="Proposal expired",te="session",A=W,ie="engine",O={wc_sessionPropose:{req:{ttl:u,prompt:!0,tag:1100},res:{ttl:u,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:u,prompt:!1,tag:1102},res:{ttl:u,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:q,prompt:!1,tag:1104},res:{ttl:q,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:q,prompt:!1,tag:1106},res:{ttl:q,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:u,prompt:!0,tag:1108},res:{ttl:u,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:u,prompt:!0,tag:1110},res:{ttl:u,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:q,prompt:!1,tag:1112},res:{ttl:q,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:Z,prompt:!1,tag:1114},res:{ttl:Z,prompt:!1,tag:1115}}},G={min:u,max:W},re="request",ne=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"];var Be=Object.defineProperty,Qe=Object.defineProperties,We=Object.getOwnPropertyDescriptors,oe=Object.getOwnPropertySymbols,Ze=Object.prototype.hasOwnProperty,es=Object.prototype.propertyIsEnumerable,ae=(d,r,e)=>r in d?Be(d,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[r]=e,w=(d,r)=>{for(var e in r||(r={}))Ze.call(r,e)&&ae(d,e,r[e]);if(oe)for(var e of oe(r))es.call(r,e)&&ae(d,e,r[e]);return d},X=(d,r)=>Qe(d,We(r));class ss extends we{constructor(r){super(r),this.name=ie,this.events=new be,this.initialized=!1,this.ignoredPayloadTypes=[Se],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(O)}),this.initialized=!0)},this.connect=async e=>{this.isInitialized();const s=X(w({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s);const{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:n,sessionProperties:a,relays:o}=s;let l=t,h,I=!1;if(l&&(I=this.client.core.pairing.pairings.get(l).active),!l||!I){const{topic:v,uri:y}=await this.client.core.pairing.create();l=v,h=y}const g=await this.client.core.crypto.generateKeyPair(),f=w({requiredNamespaces:i,optionalNamespaces:n,relays:o??[{protocol:le}],proposer:{publicKey:g,metadata:this.client.metadata}},a&&{sessionProperties:a}),{reject:m,resolve:V,done:M}=T(u,se);if(this.events.once(p("session_connect"),async({error:v,session:y})=>{if(v)m(v);else if(y){y.self.publicKey=g;const H=X(w({},y),{requiredNamespaces:y.requiredNamespaces,optionalNamespaces:y.optionalNamespaces});await this.client.session.set(y.topic,H),await this.setExpiry(y.topic,y.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:y.peer.metadata}),V(H)}}),!l){const{message:v}=c("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(v)}const C=await this.sendRequest(l,"wc_sessionPropose",f),ce=_(u);return await this.setProposal(C,w({id:C,expiry:ce},f)),{uri:h,approval:M}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i,sessionProperties:n}=e,a=this.client.proposal.get(s);let{pairingTopic:o,proposer:l,requiredNamespaces:h,optionalNamespaces:I}=a;o=o||"",K(h)||(h=Ie(i,"approve()"));const g=await this.client.core.crypto.generateKeyPair(),f=l.publicKey,m=await this.client.core.crypto.generateSharedKey(g,f);o&&s&&(await this.client.core.pairing.updateMetadata({topic:o,metadata:l.metadata}),await this.sendResult(s,o,{relay:{protocol:t??"irn"},responderPublicKey:g}),await this.client.proposal.delete(s,E("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:o}));const V=w({relay:{protocol:t??"irn"},namespaces:i,requiredNamespaces:h,optionalNamespaces:I,pairingTopic:o,controller:{publicKey:g,metadata:this.client.metadata},expiry:_(A)},n&&{sessionProperties:n});await this.client.core.relayer.subscribe(m),await this.sendRequest(m,"wc_sessionSettle",V);const M=X(w({},V),{topic:m,pairingTopic:o,acknowledged:!1,self:V.controller,peer:{publicKey:l.publicKey,metadata:l.metadata},controller:g});return await this.client.session.set(m,M),await this.setExpiry(m,_(A)),{topic:m,acknowledged:()=>new Promise(C=>setTimeout(()=>C(this.client.session.get(m)),500))}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i}=this.client.proposal.get(s);i&&(await this.sendError(s,i,t),await this.client.proposal.delete(s,E("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,i=await this.sendRequest(s,"wc_sessionUpdate",{namespaces:t}),{done:n,resolve:a,reject:o}=T();return this.events.once(p("session_update",i),({error:l})=>{l?o(l):a()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:n}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest(s,"wc_sessionExtend",{}),{done:i,resolve:n,reject:a}=T();return this.events.once(p("session_extend",t),({error:o})=>{o?a(o):n()}),await this.setExpiry(s,_(A)),{acknowledged:i}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:i,expiry:n}=e,a=await this.sendRequest(i,"wc_sessionRequest",{request:t,chainId:s},n),{done:o,resolve:l,reject:h}=T(n);return this.events.once(p("session_request",a),({error:I,result:g})=>{I?h(I):l(g)}),this.client.events.emit("session_request_sent",{topic:i,request:t,chainId:s,id:a}),await o()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:i}=t;R(t)?await this.sendResult(i,s,t.result):N(t)&&await this.sendError(i,s,t.error),this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0})},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest(s,"wc_sessionPing",{}),{done:i,resolve:n,reject:a}=T();this.events.once(p("session_ping",t),({error:o})=>{o?a(o):n()}),await i()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:i}=e;await this.sendRequest(s,"wc_sessionEvent",{event:t,chainId:i})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;this.client.session.keys.includes(s)?(await this.sendRequest(s,"wc_sessionDelete",E("USER_DISCONNECTED")),await this.deleteSession(s)):await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>_e(s,e))),this.getPendingSessionRequests=()=>(this.isInitialized(),this.client.pendingRequest.getAll()),this.cleanupDuplicatePairings=async e=>{try{const s=this.client.core.pairing.pairings.get(e.pairingTopic),t=this.client.core.pairing.pairings.getAll().filter(i=>{var n,a;return((n=i.peerMetadata)==null?void 0:n.url)&&((a=i.peerMetadata)==null?void 0:a.url)===e.self.metadata.url&&i.topic!==s.topic});if(t.length===0)return;this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`),await Promise.all(t.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}},this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await Promise.all([this.client.session.delete(e,E("USER_DISCONNECTED")),this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.deleteSymKey(e),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,E("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deletePendingSessionRequest=async(e,s,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,s),t?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.setPendingSessionRequest=async e=>{const s=O.wc_sessionRequest.req.ttl,{id:t,topic:i,params:n}=e;await this.client.pendingRequest.set(t,{id:t,topic:i,params:n}),s&&this.client.core.expirer.set(t,_(s))},this.sendRequest=async(e,s,t,i)=>{const n=Me(s,t);if(Ee()&&ne.includes(s)){const l=z(JSON.stringify(n));await this.client.core.verify.register({attestationId:l})}const a=await this.client.core.crypto.encode(e,n),o=O[s].req;return i&&(o.ttl=i),this.client.core.history.set(e,n),this.client.core.relayer.publish(e,a,o),n.id},this.sendResult=async(e,s,t)=>{const i=Ue(e,t),n=await this.client.core.crypto.encode(s,i),a=await this.client.core.history.get(s,e),o=O[a.request.method].res;this.client.core.relayer.publish(s,n,o),await this.client.core.history.resolve(i)},this.sendError=async(e,s,t)=>{const i=Ke(e,t),n=await this.client.core.crypto.encode(s,i),a=await this.client.core.history.get(s,e),o=O[a.request.method].res;this.client.core.relayer.publish(s,n,o),await this.client.core.history.resolve(i)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{P(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{P(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=e=>{const{topic:s,payload:t}=e,i=t.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,i=(await this.client.core.history.get(s,t.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidConnect(w({},s.params));const n=_(u),a=w({id:i,pairingTopic:e,expiry:n},t);await this.setProposal(i,a);const o=z(JSON.stringify(s)),l=await this.getVerifyContext(o,a.proposer.metadata);this.client.events.emit("session_proposal",{id:i,params:a,verifyContext:l})}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(R(s)){const{result:i}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const n=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const o=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:o});const l=await this.client.core.crypto.generateSharedKey(a,o);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const h=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:e})}else N(s)&&(await this.client.proposal.delete(t,E("USER_DISCONNECTED")),this.events.emit(p("session_connect"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidSessionSettleRequest(i);const{relay:n,controller:a,expiry:o,namespaces:l,requiredNamespaces:h,optionalNamespaces:I,sessionProperties:g,pairingTopic:f}=s.params,m=w({topic:e,relay:n,expiry:o,namespaces:l,acknowledged:!0,pairingTopic:f,requiredNamespaces:h,optionalNamespaces:I,controller:a.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},g&&{sessionProperties:g});await this.sendResult(s.id,e,!0),this.events.emit(p("session_connect"),{session:m}),this.cleanupDuplicatePairings(m)}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;R(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(p("session_approve",t),{})):N(s)&&(await this.client.session.delete(e,E("USER_DISCONNECTED")),this.events.emit(p("session_approve",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidUpdate(w({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult(i,e,!0),this.client.events.emit("session_update",{id:i,topic:e,params:t})}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;R(s)?this.events.emit(p("session_update",t),{}):N(s)&&this.events.emit(p("session_update",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,_(A)),await this.sendResult(t,e,!0),this.client.events.emit("session_extend",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;R(s)?this.events.emit(p("session_extend",t),{}):N(s)&&this.events.emit(p("session_extend",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult(t,e,!0),this.client.events.emit("session_ping",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{R(s)?this.events.emit(p("session_ping",t),{}):N(s)&&this.events.emit(p("session_ping",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await Promise.all([new Promise(i=>{this.client.core.relayer.once(F.publish,async()=>{i(await this.deleteSession(e))})}),this.sendResult(t,e,!0)]),this.client.events.emit("session_delete",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidRequest(w({topic:e},i)),await this.setPendingSessionRequest({id:t,topic:e,params:i});const n=z(JSON.stringify(s)),a=this.client.session.get(e),o=await this.getVerifyContext(n,a.peer.metadata);this.client.events.emit("session_request",{id:t,topic:e,params:i,verifyContext:o})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;R(s)?this.events.emit(p("session_request",t),{result:s.result}):N(s)&&this.events.emit(p("session_request",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidEmit(w({topic:e},i)),this.client.events.emit("session_event",{id:t,topic:e,params:i})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.isValidConnect=async e=>{if(!S(e)){const{message:o}=c("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(o)}const{pairingTopic:s,requiredNamespaces:t,optionalNamespaces:i,sessionProperties:n,relays:a}=e;if(x(s)||await this.isValidPairingTopic(s),!Re(a,!0)){const{message:o}=c("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(o)}!x(t)&&K(t)!==0&&this.validateNamespaces(t,"requiredNamespaces"),!x(i)&&K(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),x(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(e,s)=>{const t=Ne(e,"connect()",s);if(t)throw new Error(t.message)},this.isValidApprove=async e=>{if(!S(e))throw new Error(c("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:i,sessionProperties:n}=e;await this.isValidProposalId(s);const a=this.client.proposal.get(s),o=Y(t,"approve()");if(o)throw new Error(o.message);const l=B(a.requiredNamespaces,t,"approve()");if(l)throw new Error(l.message);if(!D(i,!0)){const{message:h}=c("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(h)}x(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async e=>{if(!S(e)){const{message:i}=c("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!fe(t)){const{message:i}=c("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=e=>{if(!S(e)){const{message:l}=c("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:s,controller:t,namespaces:i,expiry:n}=e;if(!ve(s)){const{message:l}=c("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=Pe(t,"onSessionSettleRequest()");if(a)throw new Error(a.message);const o=Y(i,"onSessionSettleRequest()");if(o)throw new Error(o.message);if(P(n)){const{message:l}=c("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!S(e)){const{message:o}=c("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(o)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const i=this.client.session.get(s),n=Y(t,"update()");if(n)throw new Error(n.message);const a=B(i.requiredNamespaces,t,"update()");if(a)throw new Error(a.message)},this.isValidExtend=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!S(e)){const{message:o}=c("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(o)}const{topic:s,request:t,chainId:i,expiry:n}=e;await this.isValidSessionTopic(s);const{namespaces:a}=this.client.session.get(s);if(!Q(a,i)){const{message:o}=c("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(o)}if(!qe(t)){const{message:o}=c("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(o)}if(!Oe(a,i,t.method)){const{message:o}=c("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(o)}if(n&&!Ve(n,G)){const{message:o}=c("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${G.min} and ${G.max}`);throw new Error(o)}},this.isValidRespond=async e=>{if(!S(e)){const{message:i}=c("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(i)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!Te(t)){const{message:i}=c("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidPing=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!S(e)){const{message:a}=c("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(a)}const{topic:s,event:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:n}=this.client.session.get(s);if(!Q(n,i)){const{message:a}=c("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(a)}if(!xe(t)){const{message:a}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(a)}if(!De(n,i,t.name)){const{message:a}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(a)}},this.isValidDisconnect=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.getVerifyContext=async(e,s)=>{const t={verified:{verifyUrl:s.verifyUrl||"",validation:"UNKNOWN",origin:s.url||""}};try{const i=await this.client.core.verify.resolve({attestationId:e,verifyUrl:s.verifyUrl});i&&(t.verified.origin=i,t.verified.validation=i===s.url?"VALID":"INVALID")}catch(i){this.client.logger.error(i)}return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`),t},this.validateSessionProps=(e,s)=>{Object.values(e).forEach(t=>{if(!D(t,!1)){const{message:i}=c("MISSING_OR_INVALID",`${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);throw new Error(i)}})}}isInitialized(){if(!this.initialized){const{message:r}=c("NOT_INITIALIZED",this.name);throw new Error(r)}}registerRelayerEvents(){this.client.core.relayer.on(F.message,async r=>{const{topic:e,message:s}=r;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);ze(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):Ye(t)&&(await this.client.core.history.resolve(t),this.onRelayEventResponse({topic:e,payload:t}))})}registerExpirerEvents(){this.client.core.expirer.on(pe.expired,async r=>{const{topic:e,id:s}=Ae(r.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,c("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit("session_expire",{topic:e})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}isValidPairingTopic(r){if(!D(r,!1)){const{message:e}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${r}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(r)){const{message:e}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${r}`);throw new Error(e)}if(P(this.client.core.pairing.pairings.get(r).expiry)){const{message:e}=c("EXPIRED",`pairing topic: ${r}`);throw new Error(e)}}async isValidSessionTopic(r){if(!D(r,!1)){const{message:e}=c("MISSING_OR_INVALID",`session topic should be a string: ${r}`);throw new Error(e)}if(!this.client.session.keys.includes(r)){const{message:e}=c("NO_MATCHING_KEY",`session topic doesn't exist: ${r}`);throw new Error(e)}if(P(this.client.session.get(r).expiry)){await this.deleteSession(r);const{message:e}=c("EXPIRED",`session topic: ${r}`);throw new Error(e)}}async isValidSessionOrPairingTopic(r){if(this.client.session.keys.includes(r))await this.isValidSessionTopic(r);else if(this.client.core.pairing.pairings.keys.includes(r))this.isValidPairingTopic(r);else if(D(r,!1)){const{message:e}=c("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${r}`);throw new Error(e)}else{const{message:e}=c("MISSING_OR_INVALID",`session or pairing topic should be a string: ${r}`);throw new Error(e)}}async isValidProposalId(r){if(!Ce(r)){const{message:e}=c("MISSING_OR_INVALID",`proposal id should be a number: ${r}`);throw new Error(e)}if(!this.client.proposal.keys.includes(r)){const{message:e}=c("NO_MATCHING_KEY",`proposal id doesn't exist: ${r}`);throw new Error(e)}if(P(this.client.proposal.get(r).expiry)){await this.deleteProposal(r);const{message:e}=c("EXPIRED",`proposal id: ${r}`);throw new Error(e)}}}class ts extends U{constructor(r,e){super(r,e,ee,L),this.core=r,this.logger=e}}class is extends U{constructor(r,e){super(r,e,te,L),this.core=r,this.logger=e}}class rs extends U{constructor(r,e){super(r,e,re,L,s=>s.id),this.core=r,this.logger=e}}class $ extends ye{constructor(r){super(r),this.protocol=j,this.version=k,this.name=b.name,this.events=new Ge,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.removeAllListeners=s=>this.events.removeAllListeners(s),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}},this.name=r?.name||b.name,this.metadata=r?.metadata||Le();const e=typeof r?.logger<"u"&&typeof r?.logger!="string"?r.logger:de(ge({level:r?.logger||b.logger}));this.core=r?.core||new he(r),this.logger=me(e,this.name),this.session=new is(this.core,this.logger),this.proposal=new ts(this.core,this.logger),this.pendingRequest=new rs(this.core,this.logger),this.engine=new ss(this)}static async init(r){const e=new $(r);return await e.initialize(),e}get context(){return ue(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(r){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(r.message),r}}}const ns=$;export{ie as ENGINE_CONTEXT,O as ENGINE_RPC_OPTS,Xe as HISTORY_CONTEXT,Je as HISTORY_EVENTS,He as HISTORY_STORAGE_VERSION,ne as METHODS_TO_VERIFY,ee as PROPOSAL_CONTEXT,Fe as PROPOSAL_EXPIRY,se as PROPOSAL_EXPIRY_MESSAGE,re as REQUEST_CONTEXT,te as SESSION_CONTEXT,A as SESSION_EXPIRY,G as SESSION_REQUEST_EXPIRY_BOUNDARIES,J as SIGN_CLIENT_CONTEXT,b as SIGN_CLIENT_DEFAULT,je as SIGN_CLIENT_EVENTS,j as SIGN_CLIENT_PROTOCOL,ke as SIGN_CLIENT_STORAGE_OPTIONS,L as SIGN_CLIENT_STORAGE_PREFIX,k as SIGN_CLIENT_VERSION,ns as SignClient,$ as default};
//# sourceMappingURL=index.es.js.map
