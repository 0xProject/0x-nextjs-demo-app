{"version":3,"sources":["../src/utils/normalizeHeaderName.ts","../src/utils/normalizeHeaderValue.ts","../src/Headers.ts","../src/transformers/headersToList.ts","../src/transformers/headersToString.ts","../src/transformers/headersToObject.ts","../src/transformers/stringToHeaders.ts","../src/transformers/listToHeaders.ts","../src/transformers/reduceHeadersObject.ts","../src/transformers/objectToHeaders.ts","../src/transformers/flattenHeadersList.ts","../src/transformers/flattenHeadersObject.ts"],"sourcesContent":["const HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i\n\nexport function normalizeHeaderName(name: string): string {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n\n  return name.toLowerCase()\n}\n","export function normalizeHeaderValue(value: string): string {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n\n  return value\n}\n","import { HeadersList, HeadersObject } from './glossary'\nimport { normalizeHeaderName } from './utils/normalizeHeaderName'\nimport { normalizeHeaderValue } from './utils/normalizeHeaderValue'\n\nconst NORMALIZED_HEADERS: unique symbol = Symbol('normalizedHeaders')\nconst RAW_HEADER_NAMES: unique symbol = Symbol('rawHeaderNames')\n\nexport default class HeadersPolyfill {\n  // Normalized header {\"name\":\"a, b\"} storage.\n  private [NORMALIZED_HEADERS]: Record<string, string> = {}\n\n  // Keeps the mapping between the raw header name\n  // and the normalized header name to ease the lookup.\n  private [RAW_HEADER_NAMES]: Map<string, string> = new Map()\n\n  constructor(init?: HeadersInit | HeadersObject | HeadersList) {\n    /**\n     * @note Cannot check if the `init` is an instance of the `Headers`\n     * because that class is only defined in the browser.\n     */\n    if (\n      ['Headers', 'HeadersPolyfill'].includes(init?.constructor.name) ||\n      init instanceof HeadersPolyfill\n    ) {\n      const initialHeaders = init as Headers\n      initialHeaders.forEach((value, name) => {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(name, Array.isArray(value) ? value.join(', ') : value)\n      })\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach((name) => {\n        const value = init[name]\n        this.append(name, Array.isArray(value) ? value.join(', ') : value)\n      })\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  *keys(): IterableIterator<string> {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield name\n    }\n  }\n\n  *values(): IterableIterator<string> {\n    for (const value of Object.values(this[NORMALIZED_HEADERS])) {\n      yield value\n    }\n  }\n\n  *entries(): IterableIterator<[string, string]> {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield [name, this.get(name)]\n    }\n  }\n\n  /**\n   * Returns a `ByteString` sequence of all the values of a header with a given name.\n   */\n  get(name: string): string | null {\n    return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] || null\n  }\n\n  /**\n   * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  set(name: string, value: string): void {\n    const normalizedName = normalizeHeaderName(name)\n    this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(value)\n    this[RAW_HEADER_NAMES].set(normalizedName, name)\n  }\n\n  /**\n   * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  append(name: string, value: string): void {\n    const normalizedName = normalizeHeaderName(name)\n    let resolvedValue = this.has(normalizedName)\n      ? `${this.get(normalizedName)}, ${value}`\n      : value\n\n    this.set(name, resolvedValue)\n  }\n\n  /**\n   * Deletes a header from the `Headers` object.\n   */\n  delete(name: string): void {\n    if (!this.has(name)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    delete this[NORMALIZED_HEADERS][normalizedName]\n    this[RAW_HEADER_NAMES].delete(normalizedName)\n  }\n\n  /**\n   * Returns the object of all the normalized headers.\n   */\n  all(): Record<string, string> {\n    return this[NORMALIZED_HEADERS]\n  }\n\n  /**\n   * Returns the object of all the raw headers.\n   */\n  raw(): Record<string, string> {\n    const rawHeaders: Record<string, string> = {}\n\n    for (const [name, value] of this.entries()) {\n      rawHeaders[this[RAW_HEADER_NAMES].get(name)] = value\n    }\n\n    return rawHeaders\n  }\n\n  /**\n   * Returns a boolean stating whether a `Headers` object contains a certain header.\n   */\n  has(name: string): boolean {\n    return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name))\n  }\n\n  /**\n   * Traverses the `Headers` object,\n   * calling the given callback for each header.\n   */\n  forEach<ThisArg = this>(\n    callback: (\n      this: ThisArg,\n      value: string,\n      name: string,\n      parent: this\n    ) => void,\n    thisArg?: ThisArg\n  ) {\n    for (const name in this[NORMALIZED_HEADERS]) {\n      if (this[NORMALIZED_HEADERS].hasOwnProperty(name)) {\n        callback.call(thisArg, this[NORMALIZED_HEADERS][name], name, this)\n      }\n    }\n  }\n}\n","import { HeadersList } from '../glossary'\n\nexport function headersToList(headers: Headers): HeadersList {\n  const headersList: HeadersList = []\n\n  headers.forEach((value, name) => {\n    const resolvedValue = value.includes(',')\n      ? value.split(',').map((value) => value.trim())\n      : value\n\n    headersList.push([name, resolvedValue])\n  })\n\n  return headersList\n}\n","import { headersToList } from './headersToList'\n\n/**\n * Converts a given `Headers` instance to its string representation.\n */\nexport function headersToString(headers: Headers): string {\n  const list = headersToList(headers)\n  const lines = list.map(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n    return `${name}: ${values.join(', ')}`\n  })\n\n  return lines.join('\\r\\n')\n}\n","import { HeadersObject } from '../glossary'\n\n// List of headers that cannot have multiple values,\n// while potentially having a comma in their single value.\nconst singleValueHeaders = ['user-agent']\n\n/**\n * Converts a given `Headers` instance into a plain object.\n * Respects headers with multiple values.\n */\nexport function headersToObject(headers: Headers): HeadersObject {\n  const headersObject: HeadersObject = {}\n\n  headers.forEach((value, name) => {\n    const isMultiValue =\n      !singleValueHeaders.includes(name.toLowerCase()) && value.includes(',')\n    headersObject[name] = isMultiValue\n      ? value.split(',').map((s) => s.trim())\n      : value\n  })\n\n  return headersObject\n}\n","import HeadersPolyfill from '../Headers'\n\n/**\n * Converts a string representation of headers (i.e. from XMLHttpRequest)\n * to a new `Headers` instance.\n */\nexport function stringToHeaders(str: string): HeadersPolyfill {\n  const lines = str.trim().split(/[\\r\\n]+/)\n\n  return lines.reduce((headers, line) => {\n    if (line.trim() === '') {\n      return headers\n    }\n\n    const parts = line.split(': ')\n    const name = parts.shift()\n    const value = parts.join(': ')\n    headers.append(name, value)\n\n    return headers\n  }, new HeadersPolyfill())\n}\n","import HeadersPolyfill from '../Headers'\nimport { HeadersList } from '../glossary'\n\nexport function listToHeaders(list: HeadersList): HeadersPolyfill {\n  const headers = new HeadersPolyfill()\n\n  list.forEach(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n\n    values.forEach((value) => {\n      headers.append(name, value)\n    })\n  })\n\n  return headers\n}\n","import { HeadersObject } from '../glossary'\n\n/**\n * Reduces given headers object instnace.\n */\nexport function reduceHeadersObject<R>(\n  headers: HeadersObject,\n  reducer: (headers: R, name: string, value: string | string[]) => R,\n  initialState: R\n): R {\n  return Object.keys(headers).reduce<R>((nextHeaders, name) => {\n    return reducer(nextHeaders, name, headers[name])\n  }, initialState)\n}\n","import HeadersPolyfill from '../Headers'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\n/**\n * Converts a given headers object to a new `Headers` instance.\n */\nexport function objectToHeaders(\n  headersObject: Record<string, string | string[] | undefined>\n): HeadersPolyfill {\n  return reduceHeadersObject(\n    headersObject,\n    (headers, name, value) => {\n      const values = ([] as string[]).concat(value).filter(Boolean)\n\n      values.forEach((value) => {\n        headers.append(name, value)\n      })\n\n      return headers\n    },\n    new HeadersPolyfill()\n  )\n}\n","import { HeadersList, FlatHeadersList } from '../glossary'\n\nexport function flattenHeadersList(list: HeadersList): FlatHeadersList {\n  return list.map(([name, values]) => {\n    return [name, ([] as string[]).concat(values).join(', ')]\n  })\n}\n","import { HeadersObject, FlatHeadersObject } from '../glossary'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\nexport function flattenHeadersObject(\n  headersObject: HeadersObject\n): FlatHeadersObject {\n  return reduceHeadersObject<FlatHeadersObject>(\n    headersObject,\n    (headers, name, value) => {\n      headers[name] = ([] as string[]).concat(value).join(', ')\n      return headers\n    },\n    {}\n  )\n}\n"],"mappings":"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","names":["value","value","value"]}