{"version":3,"file":"index.production.js","sources":["../../../query-core/build/lib/hydration.mjs","../../../query-persist-client-core/build/lib/persist.mjs","../../src/PersistQueryClientProvider.tsx","../../../query-persist-client-core/build/lib/retryStrategies.mjs"],"sourcesContent":["// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Reset fetch status to idle in the dehydrated state to avoid\n    // query being stuck in fetching state upon hydration\n\n    const dehydratedQueryState = { ...dehydratedQuery.state,\n      fetchStatus: 'idle'\n    }; // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {\n        query.setState(dehydratedQueryState);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQueryState);\n  });\n}\n\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map\n","import { hydrate, dehydrate } from '@tanstack/query-core';\n\n/**\n * Checks if emitted event is about cache change and not about observers.\n * Useful for persist, where we only want to trigger save when cache is changed.\n */\nconst cacheableEventTypes = ['added', 'removed', 'updated'];\n\nfunction isCacheableEventType(eventType) {\n  return cacheableEventTypes.includes(eventType);\n}\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\n\n\nasync function persistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24,\n  buster = '',\n  hydrateOptions\n}) {\n  try {\n    const persistedClient = await persister.restoreClient();\n\n    if (persistedClient) {\n      if (persistedClient.timestamp) {\n        const expired = Date.now() - persistedClient.timestamp > maxAge;\n        const busted = persistedClient.buster !== buster;\n\n        if (expired || busted) {\n          persister.removeClient();\n        } else {\n          hydrate(queryClient, persistedClient.clientState, hydrateOptions);\n        }\n      } else {\n        persister.removeClient();\n      }\n    }\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      queryClient.getLogger().error(err);\n      queryClient.getLogger().warn('Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.');\n    }\n\n    persister.removeClient();\n  }\n}\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\n\nasync function persistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions\n}) {\n  const persistClient = {\n    buster,\n    timestamp: Date.now(),\n    clientState: dehydrate(queryClient, dehydrateOptions)\n  };\n  await persister.persistClient(persistClient);\n}\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\n\nfunction persistQueryClientSubscribe(props) {\n  const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe(event => {\n    if (isCacheableEventType(event.type)) {\n      persistQueryClientSave(props);\n    }\n  });\n  const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe(event => {\n    if (isCacheableEventType(event.type)) {\n      persistQueryClientSave(props);\n    }\n  });\n  return () => {\n    unsubscribeQueryCache();\n    unusbscribeMutationCache();\n  };\n}\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\n\nfunction persistQueryClient(props) {\n  let hasUnsubscribed = false;\n  let persistQueryClientUnsubscribe;\n\n  const unsubscribe = () => {\n    hasUnsubscribed = true;\n    persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();\n  }; // Attempt restore\n\n\n  const restorePromise = persistQueryClientRestore(props).then(() => {\n    if (!hasUnsubscribed) {\n      // Subscribe to changes in the query cache to trigger the save\n      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);\n    }\n  });\n  return [unsubscribe, restorePromise];\n}\n\nexport { persistQueryClient, persistQueryClientRestore, persistQueryClientSave, persistQueryClientSubscribe };\n//# sourceMappingURL=persist.mjs.map\n","'use client'\nimport * as React from 'react'\n\nimport type { PersistQueryClientOptions } from '@tanstack/query-persist-client-core'\nimport { persistQueryClient } from '@tanstack/query-persist-client-core'\nimport type { QueryClientProviderProps } from '@tanstack/react-query'\nimport { QueryClientProvider, IsRestoringProvider } from '@tanstack/react-query'\n\nexport type PersistQueryClientProviderProps = QueryClientProviderProps & {\n  persistOptions: Omit<PersistQueryClientOptions, 'queryClient'>\n  onSuccess?: () => void\n}\n\nexport const PersistQueryClientProvider = ({\n  client,\n  children,\n  persistOptions,\n  onSuccess,\n  ...props\n}: PersistQueryClientProviderProps): JSX.Element => {\n  const [isRestoring, setIsRestoring] = React.useState(true)\n  const refs = React.useRef({ persistOptions, onSuccess })\n\n  React.useEffect(() => {\n    refs.current = { persistOptions, onSuccess }\n  })\n\n  React.useEffect(() => {\n    let isStale = false\n    setIsRestoring(true)\n    const [unsubscribe, promise] = persistQueryClient({\n      ...refs.current.persistOptions,\n      queryClient: client,\n    })\n\n    promise.then(() => {\n      if (!isStale) {\n        refs.current.onSuccess?.()\n        setIsRestoring(false)\n      }\n    })\n\n    return () => {\n      isStale = true\n      unsubscribe()\n    }\n  }, [client])\n\n  return (\n    <QueryClientProvider client={client} {...props}>\n      <IsRestoringProvider value={isRestoring}>{children}</IsRestoringProvider>\n    </QueryClientProvider>\n  )\n}\n","const removeOldestQuery = ({\n  persistedClient\n}) => {\n  const mutations = [...persistedClient.clientState.mutations];\n  const queries = [...persistedClient.clientState.queries];\n  const client = { ...persistedClient,\n    clientState: {\n      mutations,\n      queries\n    }\n  }; // sort queries by dataUpdatedAt (oldest first)\n\n  const sortedQueries = [...queries].sort((a, b) => a.state.dataUpdatedAt - b.state.dataUpdatedAt); // clean oldest query\n\n  if (sortedQueries.length > 0) {\n    const oldestData = sortedQueries.shift();\n    client.clientState.queries = queries.filter(q => q !== oldestData);\n    return client;\n  }\n\n  return undefined;\n};\n\nexport { removeOldestQuery };\n//# sourceMappingURL=retryStrategies.mjs.map\n"],"names":["defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","dehydrate","client","options","mutations","queries","dehydrateMutations","shouldDehydrateMutation","getMutationCache","getAll","forEach","push","mutationKey","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","getQueryCache","queryKey","queryHash","dehydrateQuery","cacheableEventTypes","isCacheableEventType","eventType","includes","async","persistQueryClientRestore","queryClient","persister","maxAge","buster","hydrateOptions","persistedClient","restoreClient","timestamp","expired","Date","now","busted","removeClient","dehydratedState","mutationCache","queryCache","dehydratedMutation","_options$defaultOptio","build","defaultOptions","dehydratedQuery","_options$defaultOptio2","get","dehydratedQueryState","fetchStatus","dataUpdatedAt","setState","hydrate","clientState","err","persistQueryClientSave","dehydrateOptions","persistClient","persistQueryClientSubscribe","props","unsubscribeQueryCache","subscribe","event","type","unusbscribeMutationCache","persistQueryClient","persistQueryClientUnsubscribe","hasUnsubscribed","then","children","persistOptions","onSuccess","isRestoring","setIsRestoring","React","useState","refs","useRef","useEffect","current","isStale","unsubscribe","promise","QueryClientProvider","_extends","createElement","IsRestoringProvider","value","sortedQueries","sort","a","b","length","oldestData","shift","filter","q"],"mappings":"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"}