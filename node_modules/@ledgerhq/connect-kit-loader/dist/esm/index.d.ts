export declare enum SupportedChains {
    EthereumMainnet = 1
}
export declare enum SupportedProviderImplementations {
    LedgerConnect = "LedgerConnect",
    WalletConnect = "WalletConnect"
}
export type EnableDebugLogsFunction = () => void;
export type CheckSupportOptions = {
    providerType: SupportedProviders;
    chainId?: number;
    bridge?: string;
    infuraId?: string;
    rpc?: {
        [chainId: number]: string;
    };
};
export type CheckSupportResult = {
    isLedgerConnectSupported: boolean;
    isLedgerConnectEnabled: boolean;
    isChainIdSupported?: boolean;
    providerImplementation: SupportedProviderImplementations;
};
export type CheckSupportFunction = (options: CheckSupportOptions) => CheckSupportResult;
export type EthereumRequestPayload = {
    method: string;
    params?: unknown[] | object;
};
export interface EthereumProvider {
    providers?: EthereumProvider[];
    connector?: unknown;
    request<T = unknown>(args: EthereumRequestPayload): Promise<T>;
    disconnect?: {
        (): Promise<void>;
    };
    emit(eventName: string | symbol, ...args: any[]): boolean;
    on(event: any, listener: any): void;
    removeListener(event: string, listener: any): void;
}
export interface SolanaProvider {
    signTransaction(...args: unknown[]): Promise<unknown>;
    signAllTransactions(...args: unknown[]): Promise<unknown>;
    signAndSendTransaction(...args: unknown[]): Promise<unknown>;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
}
export declare enum SupportedProviders {
    Ethereum = "Ethereum",
    Solana = "Solana"
}
export type ProviderResult = EthereumProvider | SolanaProvider;
export type GetProviderFunction = () => Promise<ProviderResult>;
export interface LedgerConnectKit {
    enableDebugLogs: EnableDebugLogsFunction;
    checkSupport: CheckSupportFunction;
    getProvider: GetProviderFunction;
}
export declare function loadConnectKit(): Promise<LedgerConnectKit>;
