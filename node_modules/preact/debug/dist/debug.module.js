import{Fragment as n,options as e,Component as t}from"preact";import"preact/devtools";function o(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function r(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(t)return(t=t.call(n)).next.bind(t);if(Array.isArray(n)||(t=function(n,e){if(n){if("string"==typeof n)return o(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?o(n,e):void 0}}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var r=0;return function(){return r>=n.length?{done:!0}:{done:!1,value:n[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a={};function i(){a={}}function c(e){return e.type===n?"Fragment":"function"==typeof e.type?e.type.displayName||e.type.name:"string"==typeof e.type?e.type:"#text"}var s=[],u=[];function l(){return s.length>0?s[s.length-1]:null}var f=!1;function p(e){return"function"==typeof e.type&&e.type!=n}function d(n){for(var e=[n],t=n;null!=t.__o;)e.push(t.__o),t=t.__o;return e.reduce(function(n,e){n+="  in "+c(e);var t=e.__source;return t?n+=" (at "+t.fileName+":"+t.lineNumber+")":f||(f=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),n+"\n"},"")}var h="function"==typeof WeakMap;function v(n){return n?"function"==typeof n.type?v(n.__):n:{}}var y=t.prototype.setState;t.prototype.setState=function(n,e){return null==this.__v&&null==this.state&&console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n'+d(l())),y.call(this,n,e)};var m=t.prototype.forceUpdate;function b(n){var e=n.props,t=c(n),o="";for(var r in e)if(e.hasOwnProperty(r)&&"children"!==r){var a=e[r];"function"==typeof a&&(a="function "+(a.displayName||a.name)+"() {}"),a=Object(a)!==a||a.toString?a+"":Object.prototype.toString.call(a),o+=" "+r+"="+JSON.stringify(a)}var i=e.children;return"<"+t+o+(i&&i.length?">..</"+t+">":" />")}t.prototype.forceUpdate=function(n){return null==this.__v?console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n'+d(l())):null==this.__P&&console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+d(this.__v)),m.call(this,n)},function(){!function(){var n=e.__b,t=e.diffed,o=e.__,r=e.vnode,a=e.__r;e.diffed=function(n){p(n)&&u.pop(),s.pop(),t&&t(n)},e.__b=function(e){p(e)&&s.push(e),n&&n(e)},e.__=function(n,e){u=[],o&&o(n,e)},e.vnode=function(n){n.__o=u.length>0?u[u.length-1]:null,r&&r(n)},e.__r=function(n){p(n)&&u.push(n),a&&a(n)}}();var n=!1,t=e.__b,o=e.diffed,i=e.vnode,l=e.__r,f=e.__e,y=e.__,m=e.__h,w=h?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,g=[];e.__e=function(n,e,t,o){if(e&&e.__c&&"function"==typeof n.then){var r=n;n=new Error("Missing Suspense. The throwing component was: "+c(e));for(var a=e;a;a=a.__)if(a.__c&&a.__c.__c){n=r;break}if(n instanceof Error)throw n}try{(o=o||{}).componentStack=d(e),f(n,e,t,o),"function"!=typeof n.then&&setTimeout(function(){throw n})}catch(n){throw n}},e.__=function(n,e){if(!e)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var t;switch(e.nodeType){case 1:case 11:case 9:t=!0;break;default:t=!1}if(!t){var o=c(n);throw new Error("Expected a valid HTML node as a second argument to render.\tReceived "+e+" instead: render(<"+o+" />, "+e+");")}y&&y(n,e)},e.__b=function(e){var o=e.type,r=v(e.__);if(n=!0,void 0===o)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+b(e)+"\n\n"+d(e));if(null!=o&&"object"==typeof o){if(void 0!==o.__k&&void 0!==o.__e)throw new Error("Invalid type passed to createElement(): "+o+"\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My"+c(e)+" = "+b(o)+";\n  let vnode = <My"+c(e)+" />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n"+d(e));throw new Error("Invalid type passed to createElement(): "+(Array.isArray(o)?"array":o))}if("thead"!==o&&"tfoot"!==o&&"tbody"!==o||"table"===r.type?"tr"===o&&"thead"!==r.type&&"tfoot"!==r.type&&"tbody"!==r.type&&"table"!==r.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+b(e)+"\n\n"+d(e)):"td"===o&&"tr"!==r.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+b(e)+"\n\n"+d(e)):"th"===o&&"tr"!==r.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+b(e)+"\n\n"+d(e)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+b(e)+"\n\n"+d(e)),void 0!==e.ref&&"function"!=typeof e.ref&&"object"!=typeof e.ref&&!("$$typeof"in e))throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got ['+typeof e.ref+"] instead\n"+b(e)+"\n\n"+d(e));if("string"==typeof e.type)for(var i in e.props)if("o"===i[0]&&"n"===i[1]&&"function"!=typeof e.props[i]&&null!=e.props[i])throw new Error("Component's \""+i+'" property should be a function, but got ['+typeof e.props[i]+"] instead\n"+b(e)+"\n\n"+d(e));if("function"==typeof e.type&&e.type.propTypes){if("Lazy"===e.type.displayName&&w&&!w.lazyPropTypes.has(e.type)){var s="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var u=e.type();w.lazyPropTypes.set(e.type,!0),console.warn(s+"Component wrapped in lazy() is "+c(u))}catch(n){console.warn(s+"We will log the wrapped component's name once it is loaded.")}}var l=e.props;e.type.__f&&delete(l=function(n,e){for(var t in e)n[t]=e[t];return n}({},l)).ref,function(n,e,t,o,r){Object.keys(n).forEach(function(t){var i;try{i=n[t](e,t,o,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(n){i=n}i&&!(i.message in a)&&(a[i.message]=!0,console.error("Failed prop type: "+i.message+(r&&"\n"+r()||"")))})}(e.type.propTypes,l,0,c(e),function(){return d(e)})}t&&t(e)},e.__r=function(e){l&&l(e),n=!0},e.__h=function(e,t,o){if(!e||!n)throw new Error("Hook can only be invoked from render methods.");m&&m(e,t,o)};var E=function(n,e){return{get:function(){var t="get"+n+e;g&&g.indexOf(t)<0&&(g.push(t),console.warn("getting vnode."+n+" is deprecated, "+e))},set:function(){var t="set"+n+e;g&&g.indexOf(t)<0&&(g.push(t),console.warn("setting vnode."+n+" is not allowed, "+e))}}},k={nodeName:E("nodeName","use vnode.type"),attributes:E("attributes","use vnode.props"),children:E("children","use vnode.props.children")},_=Object.create({},k);e.vnode=function(n){var e=n.props;if(null!==n.type&&null!=e&&("__source"in e||"__self"in e)){var t=n.props={};for(var o in e){var r=e[o];"__source"===o?n.__source=r:"__self"===o?n.__self=r:t[o]=r}}n.__proto__=_,i&&i(n)},e.diffed=function(e){if(e.__k&&e.__k.forEach(function(n){if("object"==typeof n&&n&&void 0===n.type){var t=Object.keys(n).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+t+"}.\n\n"+d(e))}}),n=!1,o&&o(e),null!=e.__k)for(var t=[],a=0;a<e.__k.length;a++){var i=e.__k[a];if(i&&null!=i.key){var s=i.key;if(-1!==t.indexOf(s)){console.error('Following component has two or more children with the same key attribute: "'+s+'". This may cause glitches and misbehavior in rendering process. Component: \n\n'+b(e)+"\n\n"+d(e));break}t.push(s)}}if(null!=e.__c&&null!=e.__c.__H){var u=e.__c.__H.__;if(u)for(var l=0;l<u.length;l+=1){var f=u[l];if(f.__H)for(var p,h=r(f.__H);!(p=h()).done;)if((y=p.value)!=y){var v=c(e);throw new Error("Invalid argument passed to hook. Hooks should not be called with NaN in the dependency array. Hook index "+l+" in component "+v+" was called with NaN.")}}}var y}}();export{i as resetPropWarnings};
//# sourceMappingURL=debug.module.js.map
