import type { Chain } from '../../types/chain.js';
import type { Formatter, Formatters } from '../../types/formatter.js';
import type { RpcTransaction } from '../../types/rpc.js';
import type { Transaction } from '../../types/transaction.js';
import { type ExtractFormatter, type Formatted } from './format.js';
export type TransactionFormatter<TChain extends Chain | undefined = Chain> = TChain extends Chain ? ExtractFormatter<TChain, 'transaction', NonNullable<Formatters['transaction']>> : Formatters['transaction'];
export type FormattedTransaction<TFormatter extends Formatter | undefined = Formatter> = Formatted<TFormatter, Transaction>;
export declare const transactionType: {
    readonly '0x0': "legacy";
    readonly '0x1': "eip2930";
    readonly '0x2': "eip1559";
};
export declare function formatTransaction(transaction: Partial<RpcTransaction>): Transaction;
export declare const defineTransaction: <TFormat extends Formatter<Partial<RpcTransaction>, Partial<Transaction> & {
    [key: string]: unknown;
}>, TExclude extends ("type" | "value" | "blockHash" | "blockNumber" | "from" | "gas" | "hash" | "input" | "nonce" | "r" | "s" | "to" | "transactionIndex" | "v" | "gasPrice" | "maxFeePerGas" | "maxPriorityFeePerGas" | "accessList" | "chainId")[] = []>({ exclude, format: formatOverride, }: {
    exclude?: TExclude | undefined;
    format?: TFormat | undefined;
}) => (data: Partial<RpcTransaction> & {
    [key: string]: unknown;
}) => Transaction & ReturnType<TFormat> & { [K in TExclude[number]]: never; };
//# sourceMappingURL=transaction.d.ts.map