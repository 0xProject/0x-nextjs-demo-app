import { HttpRequestError, RpcRequestError, TimeoutError, WebSocketRequestError, } from '../errors/request.js';
import { createBatchScheduler } from './promise/createBatchScheduler.js';
import { withTimeout } from './promise/withTimeout.js';
import { stringify } from './stringify.js';
let id = 0;
async function http(url, { body, fetchOptions = {}, timeout = 10000 }) {
    const { headers, method, signal: signal_ } = fetchOptions;
    try {
        const response = await withTimeout(async ({ signal }) => {
            const response = await fetch(url, {
                ...fetchOptions,
                body: stringify({ jsonrpc: '2.0', id: id++, ...body }),
                headers: {
                    ...headers,
                    'Content-Type': 'application/json',
                },
                method: method || 'POST',
                signal: signal_ || (timeout > 0 ? signal : undefined),
            });
            return response;
        }, {
            errorInstance: new TimeoutError({ body, url }),
            timeout,
            signal: true,
        });
        let data;
        if (response.headers.get('Content-Type')?.startsWith('application/json')) {
            data = await response.json();
        }
        else {
            data = await response.text();
        }
        if (!response.ok) {
            throw new HttpRequestError({
                body,
                details: stringify(data.error) || response.statusText,
                headers: response.headers,
                status: response.status,
                url,
            });
        }
        if (data.error) {
            throw new RpcRequestError({ body, error: data.error, url });
        }
        return data;
    }
    catch (err) {
        if (err instanceof HttpRequestError)
            throw err;
        if (err instanceof RpcRequestError)
            throw err;
        if (err instanceof TimeoutError)
            throw err;
        throw new HttpRequestError({
            body,
            details: err.message,
            url,
        });
    }
}
const sockets = new Map();
export async function getSocket(url_) {
    const url = new URL(url_);
    const urlKey = url.toString();
    let socket = sockets.get(urlKey);
    if (socket)
        return socket;
    const { schedule } = createBatchScheduler({
        id: urlKey,
        fn: async () => {
            let WebSocket = await import('isomorphic-ws');
            if (WebSocket.default
                ?.constructor)
                WebSocket = WebSocket
                    .default;
            else
                WebSocket = WebSocket.WebSocket;
            const webSocket = new WebSocket(url);
            const requests = new Map();
            const subscriptions = new Map();
            const onMessage = ({ data }) => {
                const message = JSON.parse(data);
                const isSubscription = message.method === 'eth_subscription';
                const id = isSubscription ? message.params.subscription : message.id;
                const cache = isSubscription ? subscriptions : requests;
                const callback = cache.get(id);
                if (callback)
                    callback({ data });
                if (!isSubscription)
                    cache.delete(id);
            };
            const onClose = () => {
                sockets.delete(urlKey);
                webSocket.removeEventListener('close', onClose);
                webSocket.removeEventListener('message', onMessage);
            };
            webSocket.addEventListener('close', onClose);
            webSocket.addEventListener('message', onMessage);
            if (webSocket.readyState === WebSocket.CONNECTING) {
                await new Promise((resolve, reject) => {
                    if (!webSocket)
                        return;
                    webSocket.onopen = resolve;
                    webSocket.onerror = reject;
                });
            }
            socket = Object.assign(webSocket, {
                requests,
                subscriptions,
            });
            sockets.set(urlKey, socket);
            return [socket];
        },
    });
    const [_, [socket_]] = await schedule();
    return socket_;
}
function webSocket(socket, { body, onData, onError, }) {
    if (socket.readyState === socket.CLOSED ||
        socket.readyState === socket.CLOSING)
        throw new WebSocketRequestError({
            body,
            url: socket.url,
            details: 'Socket is closed.',
        });
    const id_ = id++;
    const callback = ({ data }) => {
        const message = JSON.parse(data);
        if (typeof message.id === 'number' && id_ !== message.id)
            return;
        if (message.error) {
            onError?.(new RpcRequestError({ body, error: message.error, url: socket.url }));
        }
        else {
            onData?.(message);
        }
        if (body.method === 'eth_subscribe' && typeof message.result === 'string') {
            socket.subscriptions.set(message.result, callback);
        }
        if (body.method === 'eth_unsubscribe') {
            socket.subscriptions.delete(body.params?.[0]);
        }
    };
    socket.requests.set(id_, callback);
    socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }));
    return socket;
}
async function webSocketAsync(socket, { body, timeout = 10000, }) {
    return withTimeout(() => new Promise((onData, onError) => rpc.webSocket(socket, {
        body,
        onData,
        onError,
    })), {
        errorInstance: new TimeoutError({ body, url: socket.url }),
        timeout,
    });
}
export const rpc = {
    http,
    webSocket,
    webSocketAsync,
};
//# sourceMappingURL=rpc.js.map