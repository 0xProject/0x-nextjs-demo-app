import { singleAddressResolverAbi, universalResolverAbi, } from '../../constants/abis.js';
import { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';
import { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';
import { getChainContractAddress } from '../../utils/chain.js';
import { trim } from '../../utils/data/trim.js';
import { toHex } from '../../utils/encoding/toHex.js';
import { namehash } from '../../utils/ens/namehash.js';
import { packetToBytes } from '../../utils/ens/packetToBytes.js';
import { readContract, } from '../public/readContract.js';
export async function getEnsAddress(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = getChainContractAddress({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver',
        });
    }
    const res = await readContract(client, {
        address: universalResolverAddress,
        abi: universalResolverAbi,
        functionName: 'resolve',
        args: [
            toHex(packetToBytes(name)),
            encodeFunctionData({
                abi: singleAddressResolverAbi,
                functionName: 'addr',
                args: [namehash(name)],
            }),
        ],
        blockNumber,
        blockTag,
    });
    if (res[0] === '0x')
        return null;
    const address = decodeFunctionResult({
        abi: singleAddressResolverAbi,
        functionName: 'addr',
        data: res[0],
    });
    return trim(address) === '0x00' ? null : address;
}
//# sourceMappingURL=getEnsAddress.js.map