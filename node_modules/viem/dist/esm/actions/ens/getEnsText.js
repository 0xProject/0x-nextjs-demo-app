import { textResolverAbi, universalResolverAbi } from '../../constants/abis.js';
import { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';
import { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';
import { getChainContractAddress } from '../../utils/chain.js';
import { toHex } from '../../utils/encoding/toHex.js';
import { namehash } from '../../utils/ens/namehash.js';
import { packetToBytes } from '../../utils/ens/packetToBytes.js';
import { readContract, } from '../public/readContract.js';
export async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_, }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = getChainContractAddress({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver',
        });
    }
    const res = await readContract(client, {
        address: universalResolverAddress,
        abi: universalResolverAbi,
        functionName: 'resolve',
        args: [
            toHex(packetToBytes(name)),
            encodeFunctionData({
                abi: textResolverAbi,
                functionName: 'text',
                args: [namehash(name), key],
            }),
        ],
        blockNumber,
        blockTag,
    });
    if (res[0] === '0x')
        return null;
    const record = decodeFunctionResult({
        abi: textResolverAbi,
        functionName: 'text',
        data: res[0],
    });
    return record === '' ? null : record;
}
//# sourceMappingURL=getEnsText.js.map