import { getAbiItem, } from '../../utils/abi/getAbiItem.js';
import { observe } from '../../utils/observe.js';
import { poll } from '../../utils/poll.js';
import { stringify } from '../../utils/stringify.js';
import { createContractEventFilter, } from './createContractEventFilter.js';
import { getBlockNumber } from './getBlockNumber.js';
import { getFilterChanges } from './getFilterChanges.js';
import { getLogs } from './getLogs.js';
import { uninstallFilter } from './uninstallFilter.js';
export function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, pollingInterval = client.pollingInterval, }) {
    const observerId = stringify([
        'watchContractEvent',
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval,
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
        let previousBlockNumber;
        let filter;
        let initialized = false;
        const unwatch = poll(async () => {
            if (!initialized) {
                try {
                    filter = (await createContractEventFilter(client, {
                        abi,
                        address,
                        args,
                        eventName,
                    }));
                }
                catch { }
                initialized = true;
                return;
            }
            try {
                let logs;
                if (filter) {
                    logs = await getFilterChanges(client, { filter });
                }
                else {
                    const blockNumber = await getBlockNumber(client);
                    if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                        logs = await getLogs(client, {
                            address,
                            args,
                            fromBlock: previousBlockNumber + 1n,
                            toBlock: blockNumber,
                            event: getAbiItem({
                                abi,
                                name: eventName,
                            }),
                        });
                    }
                    else {
                        logs = [];
                    }
                    previousBlockNumber = blockNumber;
                }
                if (logs.length === 0)
                    return;
                if (batch)
                    emit.onLogs(logs);
                else
                    logs.forEach((log) => emit.onLogs([log]));
            }
            catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin: true,
            interval: pollingInterval,
        });
        return async () => {
            if (filter)
                await uninstallFilter(client, { filter });
            unwatch();
        };
    });
}
//# sourceMappingURL=watchContractEvent.js.map