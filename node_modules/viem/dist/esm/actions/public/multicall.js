import { multicall3Abi } from '../../constants/abis.js';
import { AbiDecodingZeroDataError } from '../../errors/abi.js';
import { RawContractError } from '../../errors/contract.js';
import { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';
import { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';
import { getChainContractAddress } from '../../utils/chain.js';
import { getContractError } from '../../utils/errors/getContractError.js';
import { readContract } from './readContract.js';
export async function multicall(client, args) {
    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_, } = args;
    const batchSize = batchSize_ ??
        ((typeof client.batch?.multicall === 'object' &&
            client.batch.multicall.batchSize) ||
            1024);
    const contracts = contracts_;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. multicallAddress is required.');
        multicallAddress = getChainContractAddress({
            blockNumber,
            chain: client.chain,
            contract: 'multicall3',
        });
    }
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i = 0; i < contracts.length; i++) {
        const { abi, address, args, functionName } = contracts[i];
        try {
            const callData = encodeFunctionData({
                abi,
                args,
                functionName,
            });
            currentChunkSize += callData.length;
            if (batchSize > 0 && currentChunkSize > batchSize) {
                currentChunk++;
                currentChunkSize = (callData.length - 2) / 2;
                chunkedCalls[currentChunk] = [];
            }
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData,
                    target: address,
                },
            ];
        }
        catch (err) {
            const error = getContractError(err, {
                abi,
                address,
                args,
                docsPath: '/docs/contract/multicall',
                functionName,
            });
            if (!allowFailure)
                throw error;
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData: '0x',
                    target: address,
                },
            ];
        }
    }
    const results = await Promise.all(chunkedCalls.map((calls) => readContract(client, {
        abi: multicall3Abi,
        address: multicallAddress,
        args: [calls],
        blockNumber,
        blockTag,
        functionName: 'aggregate3',
    })));
    return results.flat().map(({ returnData, success }, i) => {
        const calls = chunkedCalls.flat();
        const { callData } = calls[i];
        const { abi, address, functionName, args } = contracts[i];
        try {
            if (callData === '0x')
                throw new AbiDecodingZeroDataError();
            if (!success)
                throw new RawContractError({ data: returnData });
            const result = decodeFunctionResult({
                abi,
                data: returnData,
                functionName: functionName,
            });
            return allowFailure ? { result, status: 'success' } : result;
        }
        catch (err) {
            const error = getContractError(err, {
                abi,
                address,
                args,
                docsPath: '/docs/contract/multicall',
                functionName,
            });
            if (!allowFailure)
                throw error;
            return { error, result: undefined, status: 'failure' };
        }
    });
}
//# sourceMappingURL=multicall.js.map