import { toAccount } from '../accounts/toAccount.js';
import { stringToBytes, toBytes } from '../utils/encoding/toBytes.js';
export const ethersWalletToAccount = (wallet) => toAccount({
    address: wallet.address,
    async signMessage({ message }) {
        const messageBytes = (() => {
            if (typeof message === 'string')
                return stringToBytes(message);
            if (message.raw instanceof Uint8Array)
                return message.raw;
            return toBytes(message.raw);
        })();
        return (await wallet.signMessage(messageBytes));
    },
    async signTransaction(txn) {
        let type = null;
        if (txn.type === 'legacy') {
            type = 0;
        }
        else if (txn.type === 'eip1559') {
            type = 2;
        }
        else if (txn.type === 'eip2930') {
            type = 1;
        }
        return (await wallet.signTransaction({
            chainId: txn.chainId,
            data: txn.data,
            gasLimit: txn.gas,
            gasPrice: txn.gasPrice,
            nonce: txn.nonce,
            to: txn.to,
            type,
            value: txn.value,
            ...(txn.type && txn.accessList ? { accessList: txn.accessList } : {}),
            ...(txn.type === 'eip1559' && txn.maxPriorityFeePerGas
                ? { maxPriorityFeePerGas: txn.maxPriorityFeePerGas }
                : {}),
            ...(txn.type === 'eip1559' && txn.maxFeePerGas
                ? { maxFeePerGas: txn.maxFeePerGas }
                : {}),
        }));
    },
    async signTypedData({ domain, types: types_, message }) {
        const { EIP712Domain: _, ...types } = types_;
        const signTypedData = wallet.signTypedData
            ? wallet.signTypedData.bind(wallet)
            : wallet._signTypedData.bind(wallet);
        return (await signTypedData(domain ?? {}, types, message));
    },
});
//# sourceMappingURL=ethers.js.map