{"version":3,"sources":["../../config/polyfills-node.ts","../../src/node/SetupServerApi.ts","../../src/SetupApi.ts","../../src/utils/internal/devUtils.ts","../../src/utils/internal/pipeEvents.ts","../../src/utils/internal/toReadonlyArray.ts","../../src/utils/internal/isObject.ts","../../src/utils/internal/mergeRight.ts","../../src/utils/request/MockedRequest.ts","../../src/utils/request/getRequestCookies.ts","../../src/utils/internal/jsonParse.ts","../../src/utils/internal/parseMultipartData.ts","../../src/utils/request/parseBody.ts","../../src/utils/internal/isStringEqual.ts","../../src/utils/handleRequest.ts","../../src/utils/getResponse.ts","../../src/utils/request/onUnhandledRequest.ts","../../src/utils/internal/parseGraphQLRequest.ts","../../src/utils/request/getPublicUrlFromRequest.ts","../../src/context/status.ts","../../src/context/set.ts","../../src/context/cookie.ts","../../src/context/body.ts","../../src/context/json.ts","../../src/context/data.ts","../../src/context/extensions.ts","../../src/context/delay.ts","../../src/context/errors.ts","../../src/context/fetch.ts","../../src/context/text.ts","../../src/context/xml.ts","../../src/utils/logging/getStatusCodeColor.ts","../../src/utils/logging/getTimestamp.ts","../../src/utils/logging/prepareRequest.ts","../../src/utils/logging/prepareResponse.ts","../../src/utils/matching/matchRequestUrl.ts","../../src/utils/url/cleanUrl.ts","../../src/utils/url/isAbsoluteUrl.ts","../../src/utils/url/getAbsoluteUrl.ts","../../src/utils/matching/normalizePath.ts","../../src/handlers/RequestHandler.ts","../../src/response.ts","../../src/utils/internal/compose.ts","../../src/utils/NetworkError.ts","../../src/utils/internal/getCallFrame.ts","../../src/utils/internal/isIterable.ts","../../src/handlers/RestHandler.ts","../../src/context/field.ts","../../src/utils/internal/tryCatch.ts","../../src/handlers/GraphQLHandler.ts","../../src/utils/request/readResponseCookies.ts","../../src/node/setupServer.ts"],"sourcesContent":["import { setTimeout as nodeSetTimeout } from 'timers'\n\n// Polyfill the global \"setTimeout\" so MSW could be used\n// with \"jest.useFakeTimers()\". MSW response handling\n// is wrapped in \"setTimeout\", and without this polyfill\n// you'd have to manually advance the timers for the response\n// to finally resolve.\nexport const setTimeout = nodeSetTimeout\n","import chalk from 'chalk'\nimport { invariant } from 'outvariant'\nimport {\n  BatchInterceptor,\n  HttpRequestEventMap,\n  Interceptor,\n  InterceptorReadyState,\n  IsomorphicResponse,\n  MockedResponse as MockedInterceptedResponse,\n} from '@mswjs/interceptors'\nimport { SetupApi } from '../SetupApi'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { handleRequest } from '../utils/handleRequest'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { SetupServer } from './glossary'\n\n/**\n * @see https://github.com/mswjs/msw/pull/1399\n */\nconst { bold } = chalk\n\nexport type ServerLifecycleEventsMap = LifeCycleEventsMap<IsomorphicResponse>\n\nconst DEFAULT_LISTEN_OPTIONS: RequiredDeep<SharedOptions> = {\n  onUnhandledRequest: 'warn',\n}\n\nexport class SetupServerApi\n  extends SetupApi<ServerLifecycleEventsMap>\n  implements SetupServer\n{\n  protected readonly interceptor: BatchInterceptor<\n    Array<Interceptor<HttpRequestEventMap>>,\n    HttpRequestEventMap\n  >\n  private resolvedOptions: RequiredDeep<SharedOptions>\n\n  constructor(\n    interceptors: Array<{\n      new (): Interceptor<HttpRequestEventMap>\n    }>,\n    ...handlers: Array<RequestHandler>\n  ) {\n    super(...handlers)\n\n    this.interceptor = new BatchInterceptor({\n      name: 'setup-server',\n      interceptors: interceptors.map((Interceptor) => new Interceptor()),\n    })\n    this.resolvedOptions = {} as RequiredDeep<SharedOptions>\n\n    this.init()\n  }\n\n  /**\n   * Subscribe to all requests that are using the interceptor object\n   */\n  private init(): void {\n    this.interceptor.on('request', async (request) => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer(),\n      })\n\n      const response = await handleRequest<\n        MockedInterceptedResponse & { delay?: number }\n      >(\n        mockedRequest,\n        this.currentHandlers,\n        this.resolvedOptions,\n        this.emitter,\n        {\n          transformResponse(response) {\n            return {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers.all(),\n              body: response.body,\n              delay: response.delay,\n            }\n          },\n        },\n      )\n\n      if (response) {\n        // Delay Node.js responses in the listener so that\n        // the response lookup logic is not concerned with responding\n        // in any way. The same delay is implemented in the worker.\n        if (response.delay) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, response.delay)\n          })\n        }\n\n        request.respondWith(response)\n      }\n\n      return\n    })\n\n    this.interceptor.on('response', (request, response) => {\n      if (!request.id) {\n        return\n      }\n\n      if (response.headers.get('x-powered-by') === 'msw') {\n        this.emitter.emit('response:mocked', response, request.id)\n      } else {\n        this.emitter.emit('response:bypass', response, request.id)\n      }\n    })\n  }\n\n  public listen(options: Partial<SharedOptions> = {}): void {\n    this.resolvedOptions = mergeRight(\n      DEFAULT_LISTEN_OPTIONS,\n      options,\n    ) as RequiredDeep<SharedOptions>\n\n    // Apply the interceptor when starting the server.\n    this.interceptor.apply()\n\n    // Assert that the interceptor has been applied successfully.\n    // Also guards us from forgetting to call \"interceptor.apply()\"\n    // as a part of the \"listen\" method.\n    invariant(\n      [InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(\n        this.interceptor.readyState,\n      ),\n      devUtils.formatMessage(\n        'Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".',\n      ),\n      'https://github.com/mswjs/msw/issues/new/choose',\n    )\n  }\n\n  public printHandlers(): void {\n    const handlers = this.listHandlers()\n\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info\n\n      const pragma = handler.info.hasOwnProperty('operationType')\n        ? '[graphql]'\n        : '[rest]'\n\n      console.log(`\\\n${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`)\n    })\n  }\n\n  public close(): void {\n    super.dispose()\n    this.interceptor.dispose()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { EventMap, Emitter } from 'strict-event-emitter'\nimport {\n  DefaultBodyType,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n} from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { MockedRequest } from './utils/request/MockedRequest'\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMap> {\n  protected initialHandlers: ReadonlyArray<RequestHandler>\n  protected currentHandlers: Array<RequestHandler>\n  protected readonly emitter: Emitter<EventsMap>\n  protected readonly publicEmitter: Emitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler>) {\n    this.validateHandlers(...initialHandlers)\n\n    this.initialHandlers = toReadonlyArray(initialHandlers)\n    this.currentHandlers = [...initialHandlers]\n\n    this.emitter = new Emitter<EventsMap>()\n    this.publicEmitter = new Emitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n  }\n\n  private validateHandlers(...handlers: ReadonlyArray<RequestHandler>): void {\n    // Guard against incorrect call signature of the setup API.\n    for (const handler of handlers) {\n      invariant(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.',\n        ),\n        this.constructor.name,\n      )\n    }\n  }\n\n  protected dispose(): void {\n    this.emitter.removeAllListeners()\n    this.publicEmitter.removeAllListeners()\n  }\n\n  public use(...runtimeHandlers: Array<RequestHandler>): void {\n    this.currentHandlers.unshift(...runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false)\n    })\n  }\n\n  public resetHandlers(...nextHandlers: Array<RequestHandler>): void {\n    this.currentHandlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public listHandlers(): ReadonlyArray<\n    RequestHandler<\n      RequestHandlerDefaultInfo,\n      MockedRequest<DefaultBodyType>,\n      any,\n      MockedRequest<DefaultBodyType>\n    >\n  > {\n    return toReadonlyArray(this.currentHandlers)\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args: any[]) => {\n        return (this.publicEmitter.on as any)(...args)\n      },\n      removeListener: (...args: any[]) => {\n        return (this.publicEmitter.removeListener as any)(...args)\n      },\n      removeAllListeners: (...args: any[]) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n\n  abstract printHandlers(): void\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents<Events extends EventMap>(\n  source: Emitter<Events>,\n  destination: Emitter<Events>,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils.js'\nimport { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  • ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<N>]\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<CookieName>]\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import type { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess()\n    ? (input, init) =>\n        import('node-fetch').then(({ default: nodeFetch }) =>\n          (nodeFetch as unknown as typeof window.fetch)(input, init),\n        )\n    : globalThis.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import type { DefaultBodyType } from '../../handlers/RequestHandler.js'\nimport type { MockedRequest } from '../request/MockedRequest.js'\n\nexport interface LoggedRequest {\n  id: string\n  url: URL\n  method: string\n  headers: Record<string, string>\n  cookies: Record<string, string>\n  body: DefaultBodyType\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest): LoggedRequest {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<any>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  return {\n    ...res,\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders),\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl.js'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType extends DefaultBodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType extends DefaultBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType extends DefaultBodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType extends DefaultBodyType = any> =\n  ResponseFunction<BodyType> & {\n    /**\n     * Respond using a given mocked response to the first captured request.\n     * Does not affect any subsequent captured requests.\n     */\n    once: ResponseFunction<BodyType>\n    networkError: (message: string) => void\n  }\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType extends DefaultBodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport type { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse<any>) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(\n    request: MockedRequest,\n    public readonly variables: Variables,\n    public readonly operationName: string,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(\n      request,\n      parsedResult?.variables ?? {},\n      parsedResult?.operationName ?? '',\n    )\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import { ClientRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/ClientRequest/index.js'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch/index.js'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { SetupServer } from './glossary'\nimport { SetupServerApi } from './SetupServerApi'\n\n/**\n * Sets up a requests interception in Node.js with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n * @see {@link https://mswjs.io/docs/api/setup-server `setupServer`}\n */\nexport const setupServer = (\n  ...handlers: Array<RequestHandler>\n): SetupServer => {\n  return new SetupServerApi(\n    [ClientRequestInterceptor, XMLHttpRequestInterceptor, FetchInterceptor],\n    ...handlers,\n  )\n}\n"],"mappings":"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","names":["invariant","data","cookieUtils","error","name","data","field","contentType","error","body","text","body","result","parse","parse","error","value","name","cookieUtils","body","isNodeProcess","Headers","body","body","body","status","objectToHeaders","objectToHeaders","cleanUrl","Headers","Headers","Headers","error","response","response","invariant","invariant","error","error","response","strategy","store","response","response","Interceptor","response","invariant"]}